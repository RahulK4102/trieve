---
import Footer from "../../components/Footer.astro";
import SearchLayout from "../../layouts/SearchLayout.astro";
import { CollectionPage } from "../../components/CollectionPage";
import type {
  ChunkCollectionBookmarkDTO,
  ChunkCollectionBookmarksWithStatusDTO,
  ChunkCollectionSearchDTO,
} from "../../../utils/apiTypes";
import type { Filters } from "../../components/ResultsPage";
import { useStore } from "@nanostores/solid";
import { currentDataset } from "../../stores/datasetStore";

const $dataset = useStore(currentDataset);

const collectionID = Astro.params.collectionID ?? "";
const requestParams = Astro.request.url.split("?")[1];
const params = new URLSearchParams(requestParams);
const page = Number(params.get("page")) || 1;
const query = params.get("q") ?? "";
const searchType: string = params.get("searchType") ?? "semantic";

// eslint-disable-next-line @typescript-eslint/no-explicit-any
let metadataFilters: any[] = [];

params.forEach((value, key) => {
  if (
    key === "q" ||
    key === "page" ||
    key === "searchType" ||
    key === "Tag Set" ||
    key === "link"
  ) {
    return;
  }

  metadataFilters.push({
    key,
    value,
  });
});

const dataTypeFilters: Filters = {
  tagSet: params.get("Tag Set")?.split(",") ?? [],
  link: params.get("link")?.split(",") ?? [],
  metadataFilters,
  start: "",
  end: "",
};

const apiHost = import.meta.env.PUBLIC_API_HOST as string;
let collectionChunks: ChunkCollectionBookmarksWithStatusDTO = {
  metadata: {
    bookmarks: [],
    collection: {
      id: collectionID,
      name: "",
      description: "",
      author_id: "",
      created_at: "",
      updated_at: "",
    },
    total_pages: 0,
  },
  status: 0,
};

let title = "Arguflow Search";
let description = "";

try {
  const datasetId = $dataset()?.dataset.id;
  if (!datasetId) return;

  if (query === "") {
    const collectionChunkResponse = await fetch(
      `${apiHost}/chunk_collection/${collectionID}/${page}`,
      {
        method: "GET",
        headers: {
          "AF-Dataset": datasetId,
        },
      },
    );
    if (!collectionChunkResponse.ok) {
      throw new Error(
        `Failed to fetch collection chunks: ${collectionChunkResponse.status} ${collectionChunkResponse.statusText}`,
      );
    }

    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    const collectionChunkJson: ChunkCollectionBookmarkDTO =
      await collectionChunkResponse.json();
    collectionChunks = {
      metadata: collectionChunkJson,
      status: collectionChunkResponse.status,
    };
    title = `${collectionChunks.metadata.collection.name} | ` + title;
    if (collectionChunks.metadata.collection.description !== "") {
      description = collectionChunks.metadata.collection.description;
    }
  } else {
    const collectionChunkResponse = await fetch(
      `${apiHost}/chunk_collection/search/${page}`,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "AF-Dataset": datasetId,
        },
        credentials: "include",
        body: JSON.stringify({
          content: query,
          tag_set: dataTypeFilters.tagSet,
          link: dataTypeFilters.link,
          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
          filters: dataTypeFilters.metadataFilters,
          collection_id: collectionID,
          search_type: {
            search_type: searchType,
          },
        }),
      },
    );
    if (!collectionChunkResponse.ok) {
      throw new Error(
        `Failed to fetch collection chunks: ${collectionChunkResponse.status} ${collectionChunkResponse.statusText}`,
      );
    }

    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    const collectionChunkJson: ChunkCollectionSearchDTO =
      await collectionChunkResponse.json();
    collectionChunks = {
      metadata: collectionChunkJson,
      status: collectionChunkResponse.status,
    };
    title = `üîç${query} | ` + title;
  }
} catch (e) {
  console.error(e);
}
---

<SearchLayout title={title} description={description}>
  <CollectionPage
    collectionID={collectionID}
    page={page}
    defaultCollectionChunks={collectionChunks}
    query={query}
    filters={dataTypeFilters}
    searchType={searchType}
    client:load
  />
  <div class="flex-1"></div>
  <Footer />
</SearchLayout>
